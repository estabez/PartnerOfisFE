{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\soperasyon27\\\\Desktop\\\\FE\\\\src18mart\\\\src\\\\src\\\\views\\\\Matrix.jsx\";\nimport React, { createRef } from 'react';\nimport { connect } from \"react-redux\";\nimport { Row, Col, Card, CardBody, CardFooter } from 'reactstrap';\nimport { HotTable } from '@handsontable/react';\nimport Handsontable from 'handsontable';\nimport { groupingMap } from '../matrixDataMap';\nimport { columnLogic } from '../matrixColumnLogicMap';\nimport PaginationMatrix from \"../components/Pagination\";\nimport Header from '../components/Header';\nimport Sidebar from '../components/Sidebar';\nimport Toolbar from '../components/ToolbarMatrix';\nimport ModalImport from '../components/ModalImport';\nimport Spinner from '../components/Spinner';\nimport EmptyDataset from '../components/EmptyDataset';\nimport { editOnToggle, spinnerToggle } from \"../redux/actions\";\nimport { confirmAlert } from 'react-confirm-alert';\nimport 'react-confirm-alert/src/react-confirm-alert.css'; // For export File\n\nimport XLSX from 'xlsx';\nimport { saveAs } from 'file-saver'; // Rest api module import\n\nimport RestApiModule from '../RestApiModule'; // Alert module\n\nimport AlertModule from '../AlertModule';\n\nclass Matrix extends React.Component {\n  constructor(props) {\n    super(props);\n    this._isMounted = false;\n    this.restApi = new RestApiModule();\n    this.alert = new AlertModule();\n    this.hotTableComponent = createRef();\n    this.hot = null;\n    this.handsontableData = null;\n    this.handsontableDataBackup = null;\n    this.errorMessages = null;\n    this.errorBoxTitle = null;\n    this.columnHeaders = [];\n    this.titles = [];\n    this.columns = [];\n    this.handleColumnHeaders();\n    this.selectedRowCoords = {\n      r: null,\n      c: null\n    };\n    this.editedRowCoords = {\n      r: null,\n      c: null\n    };\n    this.validatedCell = {\n      r: null,\n      c: null\n    };\n    this.rowValidation = true;\n    this.filter = null;\n    this.mandatoryColumns = null;\n    this.isDuplicate = false;\n    this.submitProcessFail = false; //this.itemPerPage = +process.env.REACT_APP_MATRIX_ITEM_PER_PAGE;\n\n    this.state = {\n      isDataExistsInDB: false,\n      newRowAdded: false,\n      activePage: 1,\n      itemPerPage: +process.env.REACT_APP_MATRIX_ITEM_PER_PAGE,\n      totalCountOfData: 0,\n      exportDataAsExcelFile: null\n    };\n  }\n\n  componentDidMount() {\n    this._isMounted = true;\n\n    if (this.props.user) {\n      // get mandatory columns from map file\n      this.mandatoryColumns = this.mandatoryColumnExtractor();\n      this.setStateAsync({\n        permittedColumns: this.props.user.role.permittedColumns\n      });\n      this.hot = this.hotTableComponent.current.hotInstance;\n      this.dataLoad();\n    }\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n  }\n\n  calculatePagination(total) {\n    if (total) {\n      const pageCount = +total / this.state.itemPerPage;\n      this.setStateAsync({\n        totalCountOfData: total,\n        pageCount\n      });\n    }\n  }\n\n  dataCountOfSelectedRegion() {\n    const {\n      token,\n      region,\n      radioSite\n    } = this.props;\n\n    if (region) {\n      this.restApi.callApi('getMatrixDataCount', {\n        token,\n        region,\n        radioSite\n      }).then(response => {\n        this.calculatePagination(response.ConnectivityCount[0].Count);\n      });\n    }\n  }\n\n  async dataLoad(filterChanged) {\n    if (this._isMounted) {\n      const {\n        token,\n        region,\n        radioSite\n      } = this.props; // that means filtered options changed, so we reset the activePage number to 1\n\n      if (filterChanged) {\n        this.setStateAsync({\n          activePage: 1,\n          itemPerPage: filterChanged === \"radioSite\" ? 100 : +process.env.REACT_APP_MATRIX_ITEM_PER_PAGE\n        });\n      }\n\n      if (region) {\n        this.props.setSpinner(); // get count of data\n\n        await this.dataCountOfSelectedRegion(); //reset selected row data\n\n        this.resetSelectedRow();\n        this.restApi.callApi('getMatrixData', {\n          token,\n          region,\n          radioSite,\n          count: this.state.itemPerPage.toString(),\n          page_index: this.state.activePage.toString()\n        }).then(async response => {\n          //console.log(response)\n          // mock test\n          //response.exec_status = \"error\";\n          const {\n            ConnectivityMatrix,\n            exec_status\n          } = response; // If data doesnt exist in EAI DB we should set a flag to manage toolbar actions\n\n          if (exec_status === \"success\" && ConnectivityMatrix.length > 0) {\n            this.setStateAsync({\n              isDataExistsInDB: true\n            });\n            this.handsontableData = ConnectivityMatrix; // store the copy of data\n\n            this.hot.loadData(this.handsontableData);\n            this.paginationRowNumbers();\n            /* Filter for show active rows only*/\n\n            this.filter = this.hot.getPlugin('filters');\n            await this.revisionRowFilter();\n          } else {\n            this.setStateAsync({\n              isDataExistsInDB: false\n            });\n          } // remove spinner from screen\n\n\n          this.props.setSpinner();\n        }).catch(err => {\n          // err state. If need we can give message to user.\n          // Error handling is managed by RestApiModule.\n          // We don't need to do extra development in here\n          // Somehow if this block executed, we can only change the flag to false.\n          this.setStateAsync({\n            isDataExistsInDB: false\n          }); // remove spinner from screen\n\n          this.props.setSpinner();\n        });\n      }\n    }\n  }\n\n  setStateAsync(state) {\n    return new Promise(resolve => {\n      this.setState(state, resolve);\n    });\n  }\n\n  async handlePageChange(pageNumber) {\n    //console.log(pageNumber);\n    // TODO: call api to retrieve data for matrix page\n    // data will provided by page number\n    await this.setStateAsync({\n      activePage: pageNumber\n    });\n    this.dataLoad();\n  }\n\n  paginationRowNumbers() {\n    // break the handsontable row headers mechanism to show to user exact row numbers while paginating\n    const {\n      activePage,\n      itemPerPage\n    } = this.state;\n    const startPoint = (activePage - 1) * itemPerPage + 1;\n    const newNumbers = Array.from(Array(itemPerPage), (_, i) => startPoint + i);\n    this.hot.updateSettings({\n      rowHeaders: newNumbers\n    });\n  }\n\n  isRowCanBeEditable(r, restriction) {\n    const etatRule = this.ruleExtractor(\"etatCheckValue\");\n    const archivedRule = this.ruleExtractor(\"archivedCheckValue\");\n    const etatDataAtCell = this.hot.getDataAtRowProp(r, \"etat\");\n    const archivedDataAtCell = this.hot.getDataAtRowProp(r, \"archived\");\n    const checkEtatValue = etatRule.isValue.includes(etatDataAtCell);\n    const checkArchivedValue = archivedRule.isValue.includes(archivedDataAtCell);\n    const response = checkEtatValue && checkArchivedValue;\n\n    if (!response) {\n      const {\n        language\n      } = this.props;\n      let message,\n          title = \"\";\n\n      switch (restriction) {\n        case 'Lock':\n          title = language.lockModeRestrictionTitle;\n          message = language.lockModeRestriction;\n          break;\n\n        case 'Edit':\n        default:\n          title = language.editModeRestrictionTitle;\n          message = language.editModeRestriction;\n          break;\n      }\n\n      this.alert.showMessage(\"warning\", title, message, false);\n    }\n\n    return response;\n  } // click event handle for edit button\n\n\n  handleEditClick() {\n    const {\n      r,\n      c\n    } = this.selectedRowCoords;\n    if (r === null && c === null) return;\n\n    if (this.isRowCanBeEditable(r)) {\n      // Lock mechanism controls\n      const dto = this.prepareDTOforLockMechanism(r, false);\n      this.restApi.callApi('lock', dto).then(response => {\n        const json = response.resultLock;\n        const {\n          user\n        } = this.props; // can I continue to edit ?\n\n        const continueToEdit = json.islock && json.uname === user.name;\n\n        if (continueToEdit) {\n          // create backup data before editing;\n          this.handsontableDataBackup = JSON.parse(JSON.stringify(this.handsontableData)); // Change edit mode on redux\n\n          this.props.setEdit();\n          this.setCellProperties(r, c);\n          this.editedRowCoords.r = r;\n          this.editedRowCoords.c = c;\n        } else {\n          this.showMessageForLockMechanism(true, json);\n        }\n      });\n    }\n  } // click handle for add new row\n\n\n  async handleNewRowClick() {\n    await this.setStateAsync({\n      newRowAdded: true\n    });\n    this.editedRowCoords.r = 0;\n    this.editedRowCoords.c = 0;\n    this.isDuplicate = false; // create backup data before editing;\n\n    this.handsontableDataBackup = JSON.parse(JSON.stringify(this.handsontableData));\n    this.props.setEdit();\n    this.hot.alter('insert_row', 0, 1);\n    this.setCellProperties(0, null); // set initial value for newly adding rows\n\n    if (this.state.newRowAdded && !this.isDuplicate) {\n      this.setInitialValueOfColumn();\n    }\n  }\n\n  async handleDuplicateRowClick() {\n    const {\n      r,\n      c\n    } = this.selectedRowCoords;\n    if (r === null && c === null) return; // get existing data at row\n\n    const data = this.hot.getDataAtRow(r);\n    this.isDuplicate = true;\n    await this.handleNewRowClick(); // find radio Site column for special case. we need empty radio site for duplicated row\n\n    const radioSiteColumnIndex = this.findIndexOfColumn(0, 'radioSite');\n    const lockStatusColumnIndex = this.findIndexOfColumn(0, 'LOCK_STATUS');\n    const lockUserColumnIndex = this.findIndexOfColumn(0, 'USER_NAME');\n    const lockTimeColumnIndex = this.findIndexOfColumn(0, 'LOCK_TIME');\n    const passThisColumns = [radioSiteColumnIndex, lockStatusColumnIndex, lockUserColumnIndex, lockTimeColumnIndex]; // get column count for iteration\n\n    const colCount = this.hot.countCols(); // iterate the columns\n\n    for (let x = 0; x <= colCount; x++) {\n      // if column is this list, pass it, data will not copy from exist row\n      if (x in passThisColumns) continue; // set data\n\n      this.hot.setDataAtCell(0, x, data[x]);\n    }\n  }\n\n  handleCancelClick() {\n    if (!this.state.newRowAdded) {\n      const {\n        r,\n        c\n      } = this.editedRowCoords;\n      if (r === null && c === null) return; // Lock mechanism controls\n\n      const dto = this.prepareDTOforLockMechanism(r, false); // In all circumstances call implicit unlock\n\n      this.restApi.callApi('unlock', dto);\n    }\n\n    this.setStateAsync({\n      newRowAdded: false\n    }).then(() => {\n      this.cancelEdit();\n    });\n  }\n\n  handleSaveClick() {\n    this.saveAction();\n  }\n\n  handleSaveHistoryClick() {\n    this.saveAction(true);\n  }\n\n  checkIsRadioSiteExists(token, radioSite) {\n    return new Promise((res, rej) => {\n      const {\n        language\n      } = this.props; // if the save action doing on new row add we should check if radio site is exists\n      // then we need to show message to the user to continue or not.\n\n      this.restApi.callApi('isRadioSiteExists', {\n        token,\n        radioSite\n      }).then(radioResponse => {\n        if (radioResponse.isExist === true) {\n          // get confirmation from user to continue\n          this.alert.getConfirmation(\"warning\", language.radioSiteExistsWithSameNameTitle, language.radioSiteExistsWithSameNameText).then(confirmation => {\n            res({\n              confirmation,\n              isExists: radioResponse.isExist\n            });\n          });\n        } else {\n          // if radio site not exist we should return false\n          res({\n            confirmation: null,\n            isExists: radioResponse.isExist\n          });\n        }\n      }).catch(err => {\n        rej(err);\n      });\n    });\n  } // save action for row edited or new\n\n\n  saveAction(revision) {\n    const {\n      language,\n      token\n    } = this.props;\n    const isRevision = revision ? revision : false;\n    this.restApi.callApi('getImportStatus', {\n      token\n    }).then(importStatusResponse => {\n      const {\n        isImportOngoing\n      } = importStatusResponse;\n      const {\n        r,\n        c\n      } = this.editedRowCoords;\n\n      if (!isImportOngoing.isLock) {\n        // there isn't an import action ongoing\n        if (this.rowValidation) {\n          if (r !== null || r !== undefined) {\n            // data would send to API\n            let data = this.hot.getDataAtRow(r);\n            data = this.columns.reduce((newRowData, item, index) => {\n              Object.assign(newRowData, data[index] !== null ? {\n                [item.data]: data[index]\n              } : {\n                [item.data]: \"\"\n              });\n              return newRowData;\n            }, {});\n            const mandatoryColumnsFilled = this.checkMandatoryColumnsFilled(data);\n\n            if (mandatoryColumnsFilled) {\n              const {\n                newRowAdded: isNewRow\n              } = this.state; // radio Site exists check\n\n              if (isNewRow) {\n                this.checkIsRadioSiteExists(token, data['radioSite']).then(isExistsResponse => {\n                  const confirm = isExistsResponse.confirmation;\n\n                  if (confirm || confirm === null) {\n                    // it means, user didn't click cancel on messagebox.\n                    // confirm = null means there isnt exist radio site in db\n                    this.saveIt(token, data, isNewRow, isExistsResponse.isExists, r, c);\n                  }\n                });\n              } else {\n                this.saveIt(token, data, isNewRow, isRevision, r, c);\n              }\n            } else {\n              const title = language.mandatoryDataTitle;\n              let text = language.mandatoryDataText;\n              text = text.replace(\"{columns}\", this.mandatoryColumns.join(',<br>'));\n              this.alert.showMessage(\"error\", title, text, false);\n            }\n          }\n        } else {\n          const {\n            language\n          } = this.props;\n          this.alert.showMessage(\"error\", language.validationMessageBoxTitle, language.validationErrorGeneralMessage, false);\n        }\n      } else {\n        const message = language.importSection.ongoingImportText.replace('{username}', isImportOngoing.uname);\n        this.alert.showMessage('warning', language.importSection.ongoingImportTitle, message, false); // import is ongoing we need to reload the data\n\n        this.resetRow(r);\n        this.props.setEdit();\n        this.dataLoad();\n      }\n    });\n  }\n\n  saveIt(token, row, isNewRow, isRevision, r, c) {\n    const {\n      setSpinner,\n      setEdit\n    } = this.props;\n    setSpinner(); // Call backend to save row\n\n    this.restApi.callApi(\"saveRow\", {\n      token,\n      row,\n      isNewRow,\n      isRevision\n    }).then(response => {\n      const {\n        language\n      } = this.props;\n      const {\n        processed,\n        log\n      } = response.result;\n      const message = log.split('\\n').join('<br>');\n      setSpinner();\n\n      if (processed) {\n        this.alert.showMessage(\"success\", language.saveActionSuccessTitle, message, false);\n        this.selectedRowCoords.c = c;\n        this.selectedRowCoords.r = r;\n        this.editedRowCoords.r = null;\n        this.editedRowCoords.c = null; // Reset new row state if its true\n\n        if (this.state.newRowAdded) this.setState({\n          newRowAdded: false\n        });\n        setEdit(); // set it's not edit mode anymore\n\n        this.resetRow(r); // this method will return the edit view to normal\n\n        this.dataLoad(); // load the data again from db.\n      } else {\n        // something not suitable for BE,\n        // FE just showing a message to user.\n        this.alert.showMessage(\"error\", language.saveActionFailTitle, message, false); // this will make the row re-editable if get error from backend\n\n        this.setCellProperties(r, c);\n      }\n    }).catch(() => {\n      // we have unexpected error from BE\n      // Stopping edit mode, stop everything, back to one step previous\n      setSpinner(); //this.cancelEdit();\n      //this.resetRow(r);\n    });\n  }\n\n  async revisionRowFilter() {\n    if (this._isMounted) {\n      const colIndex = this.findIndexOfColumn(0, 'archived');\n      const {\n        showRevision\n      } = this.props;\n      const arg = showRevision ? '' : 'NO'; // this param is for filtering on handsontable\n\n      if (showRevision) {\n        this.filter.removeConditions(colIndex);\n      } else {\n        this.filter.addCondition(colIndex, 'contains', arg);\n      }\n\n      await this.filter.filter();\n    }\n  }\n\n  setCellProperties(r, c) {\n    const colCount = this.hot.countCols();\n    let col = c !== null ? c : 0;\n\n    for (let x = 0; x <= colCount; x++) {\n      const {\n        prop,\n        readOnly,\n        readOnlyInEditMode\n      } = this.hot.getCellMeta(r, x);\n      if (typeof prop !== \"string\") continue; // if prop has got readyOnly attribute with value \"true\", write permission will restricted\n      // if prop hasn't got readOnly attribute it would be false by default. So we need to check if\n      // this action is adding new row or editing existing row.\n      // if action is editing a row then we should check readOnlyInEditMode attribute of prop.\n      // if it's exist we should get opposite value because if we add this attribute to prop it value should be \"true\"\n      // it means this property can not be writable in edit mode\n      // if readOnlyInEditMode attribute is not exist in prop there isn't extra attribute checking for this cell\n      // can be writable or not. So we can put \"true\" value to associated variable.\n\n      const writable = readOnly ? !readOnly : !this.state.newRowAdded ? !readOnlyInEditMode : !readOnly;\n\n      if (writable) {\n        if (this.state.permittedColumns.indexOf(prop) >= 0) {\n          const type = this.hot.getDataType(r, x); // get cell type from loaded map\n          // this 2 row for initiate the rules on editing row.\n          //const value = this.hot.getDataAtCell(r, x);\n          //this.columnEvents(r, prop, value);\n\n          col = col === 0 ? x : col; // when add new row find first editable col.\n\n          this.hot.setCellMeta(r, x, \"editor\", type);\n          this.hot.setCellMeta(r, x, \"className\", 'bg-warning text-dark');\n        }\n      }\n    }\n\n    this.hot.render();\n    this.hot.selectCell(r, col);\n  }\n\n  findIndexOfColumn(r, propName) {\n    const colCount = this.hot.countCols();\n\n    for (let c = 0; c <= colCount; c++) {\n      const {\n        prop\n      } = this.hot.getCellMeta(r, c);\n\n      if (prop === propName) {\n        return c;\n      }\n    }\n  } // Before save action mandatory columns are must be filled\n\n\n  checkMandatoryColumnsFilled(rowData) {\n    const checkData = this.mandatoryColumns.reduce((data, columnId) => {\n      data.push(rowData[columnId]);\n      return data;\n    }, []);\n    return checkData.every(data => {\n      return data !== undefined && data !== \"\" && data !== null;\n    });\n  } // Finished initial value setter\n\n\n  setInitialValueOfColumn() {\n    this.columns.map(item => {\n      if (item.hasOwnProperty('initialValue')) {\n        this.hot.setDataAtRowProp(0, item.data, item.initialValue);\n      }\n\n      return true;\n    });\n  } // Finished, cancel edit return back to last backup data\n\n\n  cancelEdit() {\n    this.handsontableData = JSON.parse(JSON.stringify(this.handsontableDataBackup));\n    this.hot.loadData(this.handsontableData);\n    this.hot.render(); // Change edit mode on redux\n\n    this.props.setEdit();\n  } // reset row finished\n\n\n  resetRow(r) {\n    const colCount = this.hot.countCols();\n\n    for (let x = 0; x <= colCount; x++) {\n      this.hot.setCellMeta(r, x, \"editor\", false);\n      this.hot.setCellMeta(r, x, \"className\", 'bg-primary text-white');\n    }\n\n    this.hot.render();\n    this.setState({\n      newRowAdded: false\n    });\n  } // reset seleted rows for some reason such as change region, change active page\n\n\n  resetSelectedRow() {\n    this.selectedRowCoords.r = null;\n    this.selectedRowCoords.c = null;\n    this.editedRowCoords.r = null;\n    this.editedRowCoords.c = null;\n    this.validatedCell.r = null;\n    this.validatedCell.c = null;\n    this.hot.deselectCell();\n  } // disable moves finished\n\n\n  disableMoves() {\n    return false;\n  } // Finished ip validation rule\n\n\n  ipValidate(value, callback) {\n    const pat = /^(?:\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b|null)$/;\n    this.rowValidation = pat.test(value);\n    callback(this.rowValidation);\n    if (!this.rowValidation) this.showMessage(this.errorBoxTitle, this.errorMessages.invalidIP, true, true);\n  } // Finished numeric value validation\n\n\n  numericValidate(value, callback) {\n    const pat = /^\\d+$/;\n    this.rowValidation = pat.test(value);\n    callback(this.rowValidation);\n    if (!this.rowValidation) this.showMessage(this.errorBoxTitle, this.errorMessages.invalidNumber, true, true);\n  } // Finished validation message box\n\n\n  showMessage(title, message, validatorClose, isMandatoryColumn) {\n    confirmAlert({\n      title: 'Validation Warning',\n      message: message,\n      closeOnEscape: false,\n      closeOnClickOutside: false,\n      customUI: ({\n        onClose\n      }) => {\n        const closeAction = () => {\n          if (validatorClose) {\n            if (isMandatoryColumn) {\n              const {\n                r,\n                c\n              } = this.validatedCell;\n              this.hot.selectCell(r, c);\n\n              if (this.hot.getActiveEditor() !== undefined) {\n                const existingValueInCell = this.hot.getDataAtCell(r, c);\n                this.hot.getActiveEditor().beginEditing();\n                this.hot.getActiveEditor().setValue(existingValueInCell);\n              }\n            }\n\n            onClose();\n          } else {\n            this.cancelEdit();\n            onClose();\n          }\n        };\n\n        return /*#__PURE__*/React.createElement(\"div\", {\n          className: \"card\",\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 751,\n            columnNumber: 21\n          }\n        }, /*#__PURE__*/React.createElement(\"div\", {\n          className: \"card-header\",\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 752,\n            columnNumber: 25\n          }\n        }, title, /*#__PURE__*/React.createElement(\"button\", {\n          type: \"button\",\n          className: \"close\",\n          onClick: closeAction,\n          \"aria-label\": \"Close\",\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 755,\n            columnNumber: 29\n          }\n        }, /*#__PURE__*/React.createElement(\"span\", {\n          \"aria-hidden\": \"true\",\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 758,\n            columnNumber: 33\n          }\n        }, \"\\xD7\"))), /*#__PURE__*/React.createElement(\"div\", {\n          className: \"card-body\",\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 762,\n            columnNumber: 25\n          }\n        }, /*#__PURE__*/React.createElement(\"div\", {\n          className: 'card-text text-danger',\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 763,\n            columnNumber: 29\n          }\n        }, message)), /*#__PURE__*/React.createElement(\"div\", {\n          className: \"card-footer\",\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 765,\n            columnNumber: 25\n          }\n        }, /*#__PURE__*/React.createElement(\"button\", {\n          className: 'btn btn-warning',\n          onClick: closeAction,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 766,\n            columnNumber: 29\n          }\n        }, \"Ok\")));\n      }\n    });\n  } // Finished column header groups\n\n\n  handleColumnHeaders() {\n    // Create a copy of map file\n    const headerMap = JSON.parse(JSON.stringify(groupingMap)); // Set the header groups for table\n\n    const headerGrouping = headerMap.filter(item => {\n      item.colspan = item.columns.length;\n      return typeof item.columns === \"object\";\n    }); // set each and every column defaults\n\n    const cols = headerMap.map(item => {\n      return item.columns.map(c => {\n        this.titles.push(c.label);\n        c.color = item.color;\n        c.editor = false; // default readonly\n\n        if (typeof c.validator !== \"undefined\") {\n          if (c.validator === 'ipValidator') {\n            c.validator = (value, callback) => {\n              this.ipValidate(value, callback);\n            };\n          }\n\n          if (c.validator === 'isNumeric') {\n            c.validator = (value, callback) => {\n              this.numericValidate(value, callback);\n            };\n          }\n        }\n\n        if (typeof c.type !== \"undefined\") {\n          if (c.type === 'dropdown') {\n            this.setPickList(c.data).then(list => {\n              c.source = list;\n            });\n          }\n        }\n\n        if (typeof c.rerenderer !== \"undefined\") {\n          c.renderer = this.iconForLockStatusInCell.bind(this);\n          delete c.rerenderer;\n        }\n\n        return c;\n      });\n    });\n    console.log(this.columns); // spread the columns into single object\n\n    cols.map(c => {\n      console.log(c);\n      this.columns = [...this.columns, ...c];\n    }); // Pushing header group const to related vars\n\n    this.columnHeaders.push(headerGrouping);\n    this.columnHeaders.push(this.titles);\n    console.log(this.columnHeaders);\n    console.log(this.columns);\n  } // Finished colouring header\n\n\n  headerColoring(col, TH) {\n    const TR = TH.parentNode;\n    const THEAD = TR.parentNode;\n    const b = THEAD.childNodes.length;\n    const n = Array.prototype.indexOf.call(THEAD.childNodes, TR);\n    const headerLevel = -1 * b + n;\n\n    function applyClass(elem, className) {\n      if (!Handsontable.dom.hasClass(elem, className)) Handsontable.dom.addClass(elem, className);\n    }\n\n    if (headerLevel === -1 || headerLevel === -2) {\n      if (col in this.columns) {\n        const {\n          color\n        } = this.columns[col];\n        if (color) applyClass(TH, color);\n      }\n    }\n  } // Finished pick list setter function\n\n\n  setPickList(name) {\n    return new Promise((res, rej) => {\n      const value = `${name}Picklist_value`;\n      const key = `${name}Picklist`;\n      this.restApi.callApi('getPickList', {\n        token: this.props.token,\n        pickListName: key\n      }).then(response => {\n        if (response.pickList.length > 0) {\n          const list = response.pickList.map(item => {\n            return item[value];\n          });\n          res(list);\n        }\n      }).catch(error => {\n        console.log(error);\n      });\n    });\n  } // Read the rule from imported rule file\n\n\n  mandatoryColumnExtractor() {\n    return groupingMap.reduce((fullArr, item) => {\n      const cols = item.columns.reduce((arr, col) => {\n        if (col.mandatory) arr.push(col.data);\n        return arr;\n      }, []);\n      return [...fullArr, ...cols];\n    }, []);\n  } // Read the rule from imported rule file\n\n\n  ruleExtractor(columnId) {\n    return columnLogic.find(item => {\n      return item.id === columnId;\n    });\n  } // Generic attributes validations and rule runner\n\n\n  async columnEvents(r, c, newV) {\n    this.validatedCell.r = r;\n    this.validatedCell.c = c;\n    const properties = this.ruleExtractor(c);\n\n    if (properties) {\n      const {\n        methodCaller,\n        rules,\n        executeRules,\n        paramName,\n        additionalParams,\n        ruleChain\n      } = properties;\n\n      if (methodCaller) {\n        // we understand that this logic needs to call api\n        // default dto\n        let dto = {\n          token: this.props.token,\n          [paramName]: this.hot.getDataAtRowProp(r, c)\n        };\n\n        if (typeof additionalParams !== 'undefined' && typeof additionalParams === 'object') {\n          // create addition parameter to bind exact one\n          const additionalDTO = additionalParams.map(prop => {\n            return {\n              [prop]: this.hot.getDataAtRowProp(r, prop)\n            };\n          }); // dto with additional parameters\n\n          dto = Object.assign({}, dto, ...additionalDTO);\n        } // method caller and logic execution\n        //await this.genericCL(methodCaller, dto);\n\n\n        this.restApi.callApi(methodCaller, dto).then(response => {\n          if (typeof response.isExist !== 'undefined') {\n            if (!response.isExist) {\n              // value is not exist in DB, show message\n              // add this row, if column is mandatory, user must fill this cell with correct value\n              const isMandatoryColumn = this.mandatoryColumns.includes(c); // show message and execute logic\n\n              this.showMessage(this.errorBoxTitle, this.errorMessages[c], true, isMandatoryColumn);\n              this.rowValidation = false; // row has error\n\n              return false;\n            } else {\n              // value is exist in DB, check other rules associated with that one\n              if (executeRules && executeRules.length > 0) {\n                executeRules.map(props => {\n                  const {\n                    propId\n                  } = props;\n                  const data = this.hot.getDataAtRowProp(r, propId);\n                  this.columnEvents(r, propId, data);\n                });\n              }\n\n              this.rowValidation = true; // row passed all validation\n            }\n\n            if (ruleChain && ruleChain.length > 0) {\n              this.ruleChainHandle(ruleChain, dto, r);\n            }\n          } else {\n            rules[0].changedValue = response.List.map(i => {\n              return i.value;\n            });\n            this.staticRules(r, null, rules);\n          }\n        });\n      } else {\n        this.staticRules(r, newV, rules);\n      }\n    }\n  }\n\n  ruleChainHandle(ruleChain, dto, r) {\n    ruleChain.map(item => {\n      if (item.parentResponse) {\n        this.restApi.callApi(item.methodCaller, dto).then(response => {\n          const {\n            exec_status\n          } = response;\n\n          if (item.responseType === \"string\") {\n            const value = response[item.parsingKey];\n\n            if (exec_status === \"success\") {\n              this.staticRules(r, value, item.rules);\n            }\n          }\n\n          if (item.responseType === \"object\") {\n            const obj = response[item.parsingKey];\n            const list = obj.reduce((arr, i) => {\n              return [...arr, i[item.parsingKey]];\n            }, []);\n            this.hot.setCellMeta(r, this.hot.propToCol(item.parsingKey), 'source', list);\n            this.hot.setDataAtRowProp(r, item.parsingKey, list[0]);\n          }\n        });\n      }\n    });\n  }\n\n  staticRules(r, value, rules) {\n    if (rules) {\n      rules.map(item => {\n        if (item.columnValue && value) {\n          if (item.columnValue === value) {\n            // status changes\n            this.hot.setDataAtRowProp(r, item.changedId, item.changedValue);\n          }\n        } else if (!item.columnValue && value) {\n          this.hot.setDataAtRowProp(r, item.changedId, value);\n        } else {\n          this.hot.setCellMeta(r, this.hot.propToCol(item.changedId), 'source', item.changedValue);\n        }\n      });\n    }\n  }\n\n  handleExport() {\n    const {\n      token,\n      region,\n      radioSite\n    } = this.props;\n    this.props.setSpinner();\n    this.restApi.callApi('exportData', {\n      region,\n      token,\n      radioSite\n    }).then(response => {\n      const today = new Date(); //const todayDate =  '_' + today.getDate() +  (today.toLocaleString('default', { month: 'long' })) + today.getFullYear();\n\n      const todayDate = '_' + today.getFullYear() + '-' + (today.getMonth() + 1) + '-' + today.getDate() + 'T' + today.getHours() + '.' + today.getMinutes();\n      const ws = XLSX.utils.json_to_sheet(response.ExportedExcelAsJSON);\n      const wb = {\n        Sheets: {\n          'data': ws\n        },\n        SheetNames: ['data']\n      };\n      const excelBuffer = XLSX.write(wb, {\n        bookType: 'xlsx',\n        type: 'array'\n      });\n      const data = new Blob([excelBuffer], {\n        type: 'xlsx'\n      }); // saveAs(data, `DataMatrix${todayDate}.xlsx`);\n\n      saveAs(data, `Exported_RANConn${todayDate}.xlsx`);\n      this.props.setSpinner();\n    }).catch(error => {\n      console.log(error);\n      this.props.setSpinner();\n    });\n  }\n\n  handleLockClick() {\n    const {\n      r\n    } = this.selectedRowCoords;\n    if (r === null) return;\n\n    if (this.isRowCanBeEditable(r, 'Lock')) {\n      const dto = this.prepareDTOforLockMechanism(r, true);\n      this.restApi.callApi('lock', dto).then(response => {\n        this.showMessageForLockMechanism(true, response.resultLock);\n        this.dataLoad();\n      });\n    }\n  }\n\n  handleUnlockClick() {\n    const {\n      r\n    } = this.selectedRowCoords;\n    if (r === null) return;\n\n    if (this.isRowCanBeEditable(r, 'Lock')) {\n      const dto = this.prepareDTOforLockMechanism(r, true);\n      this.restApi.callApi('unlock', dto).then(response => {\n        this.showMessageForLockMechanism(false, response.resultUnlock);\n        this.dataLoad();\n      });\n    }\n  }\n\n  prepareDTOforLockMechanism(r, isExplicit) {\n    const {\n      token\n    } = this.props; // get existing data at row\n\n    const data = this.hot.getDataAtRow(r);\n    const radioSiteColumnIndex = this.findIndexOfColumn(0, 'radioSite');\n    const revisionNumberColumnIndex = this.findIndexOfColumn(0, 'revisionNumber');\n    const radioSite = data[radioSiteColumnIndex].toString();\n    const revisionNumber = data[revisionNumberColumnIndex].toString();\n    return {\n      token,\n      radioSite,\n      revisionNumber,\n      isExplicit\n    };\n  }\n\n  showMessageForLockMechanism(messageForLock, result) {\n    const {\n      lockMechanism,\n      unlockMechanism\n    } = this.props.language;\n    const title = messageForLock ? lockMechanism.title : unlockMechanism.title;\n    let message = messageForLock ? lockMechanism[result.code.toString()] : unlockMechanism[result.code.toString()];\n    message = message ? message.replace(\"{uname}\", result.uname).replace(\"{time}\", new Date(result.time).toLocaleString()) : \"Undefined\";\n    this.alert.showMessage('info', title, message, false);\n  }\n\n  iconForLockStatusInCell(instance, td, row, col, prop, value) {\n    const {\n      language\n    } = this.props;\n\n    switch (value) {\n      case \"Locked_Current_User\":\n        {\n          const message = language.lockStatusMessages.Locked_Current_User;\n          td.innerHTML = '<strong class=\"icon icon-lock-locked text-danger\" title=\"' + message + '\" />';\n        }\n        break;\n\n      case \"Locked_Other_User\":\n        {\n          const message = language.lockStatusMessages.Locked_Other_User;\n          td.innerHTML = '<strong class=\"text-danger\" title=\"' + message + '\">' + '<i class=\"icon icon-lock-locked\"></i>' + '<i class=\"icon icon-avatar\"></i>' + '</strong>';\n        }\n        break;\n\n      default:\n        {\n          const message = language.lockStatusMessages.Not_Locked;\n          td.innerHTML = '<strong class=\"icon icon-lock-unlocked\" title=\"' + message + '\" />';\n        }\n        break;\n    }\n\n    td.classList.add(\"text-center\");\n    return td;\n  }\n\n  shouldComponentUpdate(nextProps, nextState, nextContext) {\n    return nextState.isDataExistsInDB !== this.state.isDataExistsInDB || nextState.activePage !== this.state.activePage || nextState.totalCountOfData !== this.state.totalCountOfData || nextState.newRowAdded !== this.state.newRowAdded || nextState.maximize !== this.props.maximize;\n  }\n\n  render() {\n    const {\n      maximize,\n      language,\n      contentCSS,\n      showRevision\n    } = this.props;\n\n    if (language) {\n      this.errorBoxTitle = language.validationMessageBoxTitle;\n      this.errorMessages = language.validationErrorMessages;\n    }\n\n    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Header, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1179,\n        columnNumber: 17\n      }\n    }), /*#__PURE__*/React.createElement(Row, {\n      className: \"h-100\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1180,\n        columnNumber: 17\n      }\n    }, /*#__PURE__*/React.createElement(Sidebar, {\n      maximize: maximize,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1181,\n        columnNumber: 21\n      }\n    }), /*#__PURE__*/React.createElement(Col, {\n      className: contentCSS,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1182,\n        columnNumber: 21\n      }\n    }, /*#__PURE__*/React.createElement(Toolbar, {\n      wrapper: 'toolbar mt-2',\n      isDataExist: this.state.isDataExistsInDB,\n      newRowAdded: this.state.newRowAdded,\n      export: this.handleExport.bind(this),\n      lock: this.handleLockClick.bind(this),\n      unlock: this.handleUnlockClick.bind(this),\n      new: this.handleNewRowClick.bind(this),\n      duplicate: this.handleDuplicateRowClick.bind(this),\n      edit: this.handleEditClick.bind(this),\n      cancel: this.handleCancelClick.bind(this),\n      save: this.handleSaveClick.bind(this),\n      \"save-history\": this.handleSaveHistoryClick.bind(this),\n      revision: this.revisionRowFilter.bind(this),\n      handleRegionChange: this.dataLoad.bind(this),\n      handleRadioSiteChange: this.dataLoad.bind(this),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1183,\n        columnNumber: 25\n      }\n    }), /*#__PURE__*/React.createElement(Card, {\n      className: 'mt-1 fixedCard',\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1201,\n        columnNumber: 25\n      }\n    }, /*#__PURE__*/React.createElement(CardBody, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1202,\n        columnNumber: 29\n      }\n    }, /*#__PURE__*/React.createElement(HotTable, {\n      ref: this.hotTableComponent,\n      id: 'hot',\n      licenseKey: 'non-commercial-and-evaluation',\n      nestedHeaders: this.columnHeaders,\n      columns: this.columns,\n      stretchH: 'all',\n      dropdownMenu: true,\n      filters: true,\n      manualColumnResize: true,\n      width: '100%',\n      height: '100%',\n      fixedColumnsLeft: 0,\n      columnSorting: true,\n      currentRowClassName: ['bg-primary', 'text-white'],\n      enterBeginsEditing: false,\n      outsideClickDeselects: false,\n      enterMoves: this.disableMoves(),\n      fillHandle: this.disableMoves(),\n      afterSelectionEnd: (r, c) => {\n        this.selectedRowCoords.r = r;\n        this.selectedRowCoords.c = c;\n      },\n      afterValidate: (isValid, value, row, prop) => {\n        // this is check dropdown values are proper or not.\n        this.validatedCell.r = row;\n        this.validatedCell.c = prop;\n      },\n      afterGetColHeader: (col, TH) => {\n        this.headerColoring(col, TH);\n      },\n      afterCreateRow: (index, amount, source) => {//console.log(index, amount, source)\n      },\n      afterRenderer: (td, r) => {\n        if (showRevision) {\n          const v = this.hot.getDataAtRowProp(r, 'archived');\n\n          if (['YES', 'Yes', 'yes'].includes(v)) {\n            td.classList.add('revision-row');\n          }\n        }\n      },\n      afterChange: changes => {\n        // TODO: check esc button when its clicked\n        if (changes) {\n          const [r, c, oldV, newV] = changes[0]; // check cell value if it's different previous one and\n          // if row still has error -> we need that because\n          // if user doesnt change value at second time, validation rule not execute.\n\n          if (oldV !== newV || !this.rowValidation) this.columnEvents(r, c, newV);\n        }\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1203,\n        columnNumber: 33\n      }\n    }), !this.state.isDataExistsInDB && /*#__PURE__*/React.createElement(EmptyDataset, {\n      page: 'matrix',\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1257,\n        columnNumber: 37\n      }\n    }))))), /*#__PURE__*/React.createElement(ModalImport, {\n      loadAfterImport: this.dataLoad.bind(this),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1273,\n        columnNumber: 17\n      }\n    }), /*#__PURE__*/React.createElement(Spinner, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 1274,\n        columnNumber: 17\n      }\n    }));\n  }\n\n}\n\nfunction mapStateToProps(state) {\n  return {\n    token: state.token,\n    user: state.user,\n    language: state.language,\n    maximize: state.maximize,\n    contentCSS: state.contentCSS,\n    region: state.region,\n    radioSite: state.radioSite,\n    spinnerToggle: state.spinnerToggle,\n    showRevision: state.showRevision\n  };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    setEdit: () => dispatch(editOnToggle()),\n    setSpinner: () => dispatch(spinnerToggle())\n  };\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Matrix);","map":{"version":3,"sources":["C:/Users/soperasyon27/Desktop/FE/src18mart/src/src/views/Matrix.jsx"],"names":["React","createRef","connect","Row","Col","Card","CardBody","CardFooter","HotTable","Handsontable","groupingMap","columnLogic","PaginationMatrix","Header","Sidebar","Toolbar","ModalImport","Spinner","EmptyDataset","editOnToggle","spinnerToggle","confirmAlert","XLSX","saveAs","RestApiModule","AlertModule","Matrix","Component","constructor","props","_isMounted","restApi","alert","hotTableComponent","hot","handsontableData","handsontableDataBackup","errorMessages","errorBoxTitle","columnHeaders","titles","columns","handleColumnHeaders","selectedRowCoords","r","c","editedRowCoords","validatedCell","rowValidation","filter","mandatoryColumns","isDuplicate","submitProcessFail","state","isDataExistsInDB","newRowAdded","activePage","itemPerPage","process","env","REACT_APP_MATRIX_ITEM_PER_PAGE","totalCountOfData","exportDataAsExcelFile","componentDidMount","user","mandatoryColumnExtractor","setStateAsync","permittedColumns","role","current","hotInstance","dataLoad","componentWillUnmount","calculatePagination","total","pageCount","dataCountOfSelectedRegion","token","region","radioSite","callApi","then","response","ConnectivityCount","Count","filterChanged","setSpinner","resetSelectedRow","count","toString","page_index","ConnectivityMatrix","exec_status","length","loadData","paginationRowNumbers","getPlugin","revisionRowFilter","catch","err","Promise","resolve","setState","handlePageChange","pageNumber","startPoint","newNumbers","Array","from","_","i","updateSettings","rowHeaders","isRowCanBeEditable","restriction","etatRule","ruleExtractor","archivedRule","etatDataAtCell","getDataAtRowProp","archivedDataAtCell","checkEtatValue","isValue","includes","checkArchivedValue","language","message","title","lockModeRestrictionTitle","lockModeRestriction","editModeRestrictionTitle","editModeRestriction","showMessage","handleEditClick","dto","prepareDTOforLockMechanism","json","resultLock","continueToEdit","islock","uname","name","JSON","parse","stringify","setEdit","setCellProperties","showMessageForLockMechanism","handleNewRowClick","alter","setInitialValueOfColumn","handleDuplicateRowClick","data","getDataAtRow","radioSiteColumnIndex","findIndexOfColumn","lockStatusColumnIndex","lockUserColumnIndex","lockTimeColumnIndex","passThisColumns","colCount","countCols","x","setDataAtCell","handleCancelClick","cancelEdit","handleSaveClick","saveAction","handleSaveHistoryClick","checkIsRadioSiteExists","res","rej","radioResponse","isExist","getConfirmation","radioSiteExistsWithSameNameTitle","radioSiteExistsWithSameNameText","confirmation","isExists","revision","isRevision","importStatusResponse","isImportOngoing","isLock","undefined","reduce","newRowData","item","index","Object","assign","mandatoryColumnsFilled","checkMandatoryColumnsFilled","isNewRow","isExistsResponse","confirm","saveIt","mandatoryDataTitle","text","mandatoryDataText","replace","join","validationMessageBoxTitle","validationErrorGeneralMessage","importSection","ongoingImportText","ongoingImportTitle","resetRow","row","processed","log","result","split","saveActionSuccessTitle","saveActionFailTitle","colIndex","showRevision","arg","removeConditions","addCondition","col","prop","readOnly","readOnlyInEditMode","getCellMeta","writable","indexOf","type","getDataType","setCellMeta","render","selectCell","propName","rowData","checkData","columnId","push","every","map","hasOwnProperty","setDataAtRowProp","initialValue","deselectCell","disableMoves","ipValidate","value","callback","pat","test","invalidIP","numericValidate","invalidNumber","validatorClose","isMandatoryColumn","closeOnEscape","closeOnClickOutside","customUI","onClose","closeAction","getActiveEditor","existingValueInCell","getDataAtCell","beginEditing","setValue","headerMap","headerGrouping","colspan","cols","label","color","editor","validator","setPickList","list","source","rerenderer","renderer","iconForLockStatusInCell","bind","console","headerColoring","TH","TR","parentNode","THEAD","b","childNodes","n","prototype","call","headerLevel","applyClass","elem","className","dom","hasClass","addClass","key","pickListName","pickList","error","fullArr","arr","mandatory","find","id","columnEvents","newV","properties","methodCaller","rules","executeRules","paramName","additionalParams","ruleChain","additionalDTO","propId","ruleChainHandle","changedValue","List","staticRules","parentResponse","responseType","parsingKey","obj","propToCol","columnValue","changedId","handleExport","today","Date","todayDate","getFullYear","getMonth","getDate","getHours","getMinutes","ws","utils","json_to_sheet","ExportedExcelAsJSON","wb","Sheets","SheetNames","excelBuffer","write","bookType","Blob","handleLockClick","handleUnlockClick","resultUnlock","isExplicit","revisionNumberColumnIndex","revisionNumber","messageForLock","lockMechanism","unlockMechanism","code","time","toLocaleString","instance","td","lockStatusMessages","Locked_Current_User","innerHTML","Locked_Other_User","Not_Locked","classList","add","shouldComponentUpdate","nextProps","nextState","nextContext","maximize","contentCSS","validationErrorMessages","isValid","amount","v","changes","oldV","mapStateToProps","mapDispatchToProps","dispatch"],"mappings":"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","sourcesContent":["import React, {createRef} from 'react';\r\nimport {connect} from \"react-redux\";\r\nimport {Row, Col, Card, CardBody, CardFooter} from 'reactstrap';\r\n\r\nimport {HotTable} from '@handsontable/react';\r\nimport Handsontable from 'handsontable';\r\nimport {groupingMap} from '../matrixDataMap';\r\nimport {columnLogic} from '../matrixColumnLogicMap';\r\n\r\nimport PaginationMatrix from \"../components/Pagination\"\r\n\r\nimport Header from '../components/Header';\r\nimport Sidebar from '../components/Sidebar';\r\nimport Toolbar from '../components/ToolbarMatrix';\r\nimport ModalImport from '../components/ModalImport';\r\nimport Spinner from '../components/Spinner';\r\nimport EmptyDataset from '../components/EmptyDataset';\r\n\r\nimport {editOnToggle, spinnerToggle} from \"../redux/actions\";\r\n\r\nimport { confirmAlert } from 'react-confirm-alert';\r\nimport 'react-confirm-alert/src/react-confirm-alert.css';\r\n\r\n// For export File\r\nimport XLSX from 'xlsx'\r\nimport {saveAs} from 'file-saver';\r\n\r\n// Rest api module import\r\nimport RestApiModule from '../RestApiModule'\r\n\r\n// Alert module\r\nimport AlertModule from '../AlertModule'\r\n\r\nclass Matrix extends React.Component {\r\n    _isMounted = false;\r\n\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.restApi = new RestApiModule();\r\n        this.alert = new AlertModule();\r\n\r\n        this.hotTableComponent = createRef();\r\n        this.hot = null;\r\n        this.handsontableData = null;\r\n        this.handsontableDataBackup = null;\r\n\r\n        this.errorMessages = null;\r\n        this.errorBoxTitle = null;\r\n        this.columnHeaders = [];\r\n        this.titles = [];\r\n        this.columns = [];\r\n        this.handleColumnHeaders();\r\n\r\n        this.selectedRowCoords = {r: null, c: null};\r\n        this.editedRowCoords = {r: null, c: null};\r\n        this.validatedCell = {r: null, c: null};\r\n        this.rowValidation = true;\r\n        this.filter = null;\r\n        this.mandatoryColumns = null;\r\n        this.isDuplicate = false;\r\n        this.submitProcessFail = false;\r\n\r\n\r\n        //this.itemPerPage = +process.env.REACT_APP_MATRIX_ITEM_PER_PAGE;\r\n        this.state = {\r\n            isDataExistsInDB: false,\r\n            newRowAdded: false,\r\n            activePage: 1,\r\n            itemPerPage: +process.env.REACT_APP_MATRIX_ITEM_PER_PAGE,\r\n            totalCountOfData: 0,\r\n            exportDataAsExcelFile: null\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        this._isMounted = true;\r\n\r\n        if (this.props.user) {\r\n\r\n            // get mandatory columns from map file\r\n            this.mandatoryColumns = this.mandatoryColumnExtractor();\r\n\r\n            this.setStateAsync({permittedColumns: this.props.user.role.permittedColumns});\r\n            this.hot = this.hotTableComponent.current.hotInstance;\r\n\r\n            this.dataLoad();\r\n        }\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        this._isMounted = false;\r\n    }\r\n\r\n    calculatePagination(total) {\r\n\r\n        if (total) {\r\n            const pageCount = +total / this.state.itemPerPage;\r\n            this.setStateAsync({totalCountOfData: total, pageCount})\r\n        }\r\n    }\r\n\r\n    dataCountOfSelectedRegion() {\r\n\r\n        const {token, region, radioSite} = this.props;\r\n\r\n        if (region) {\r\n            this.restApi.callApi('getMatrixDataCount', {\r\n                token,\r\n                region,\r\n                radioSite\r\n            }).then(response => {\r\n                this.calculatePagination(response.ConnectivityCount[0].Count)\r\n            })\r\n        }\r\n    }\r\n\r\n    async dataLoad(filterChanged) {\r\n\r\n        if (this._isMounted) {\r\n            const {token, region, radioSite} = this.props;\r\n\r\n            // that means filtered options changed, so we reset the activePage number to 1\r\n            if (filterChanged) {\r\n\r\n                this.setStateAsync({\r\n                    activePage: 1,\r\n                    itemPerPage: (filterChanged === \"radioSite\") ? 100 : +process.env.REACT_APP_MATRIX_ITEM_PER_PAGE\r\n                });\r\n            }\r\n\r\n            if (region) {\r\n                this.props.setSpinner();\r\n\r\n                // get count of data\r\n                await this.dataCountOfSelectedRegion()\r\n\r\n                //reset selected row data\r\n                this.resetSelectedRow()\r\n\r\n                this.restApi.callApi('getMatrixData', {\r\n                    token,\r\n                    region,\r\n                    radioSite,\r\n                    count: this.state.itemPerPage.toString(),\r\n                    page_index: this.state.activePage.toString()\r\n                }).then(async (response) => {\r\n                    //console.log(response)\r\n\r\n                    // mock test\r\n                    //response.exec_status = \"error\";\r\n\r\n                    const {ConnectivityMatrix, exec_status} = response;\r\n\r\n                    // If data doesnt exist in EAI DB we should set a flag to manage toolbar actions\r\n                    if (exec_status === \"success\" &&\r\n                        ConnectivityMatrix.length > 0) {\r\n\r\n                        this.setStateAsync({isDataExistsInDB: true});\r\n\r\n                        this.handsontableData = ConnectivityMatrix; // store the copy of data\r\n                        this.hot.loadData(this.handsontableData);\r\n\r\n                        this.paginationRowNumbers();\r\n\r\n                        /* Filter for show active rows only*/\r\n                        this.filter = this.hot.getPlugin('filters');\r\n\r\n                        await this.revisionRowFilter();\r\n\r\n                    } else {\r\n\r\n                        this.setStateAsync({isDataExistsInDB: false});\r\n                    }\r\n\r\n                    // remove spinner from screen\r\n                    this.props.setSpinner();\r\n\r\n                }).catch(err => {\r\n                    // err state. If need we can give message to user.\r\n                    // Error handling is managed by RestApiModule.\r\n                    // We don't need to do extra development in here\r\n\r\n                    // Somehow if this block executed, we can only change the flag to false.\r\n                    this.setStateAsync({isDataExistsInDB: false});\r\n\r\n                    // remove spinner from screen\r\n                    this.props.setSpinner();\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    setStateAsync(state) {\r\n        return new Promise((resolve) => {\r\n            this.setState(state, resolve)\r\n        });\r\n    }\r\n\r\n    async handlePageChange(pageNumber) {\r\n        //console.log(pageNumber);\r\n        // TODO: call api to retrieve data for matrix page\r\n        // data will provided by page number\r\n        await this.setStateAsync({activePage: pageNumber});\r\n        this.dataLoad();\r\n    }\r\n\r\n    paginationRowNumbers() {\r\n        // break the handsontable row headers mechanism to show to user exact row numbers while paginating\r\n        const {activePage, itemPerPage} = this.state;\r\n\r\n        const startPoint =((activePage - 1) * itemPerPage) + 1;\r\n        const newNumbers = Array.from(Array(itemPerPage), (_, i) => startPoint + i)\r\n\r\n        this.hot.updateSettings({\r\n            rowHeaders: newNumbers\r\n        })\r\n    }\r\n\r\n    isRowCanBeEditable(r, restriction) {\r\n\r\n        const etatRule = this.ruleExtractor(\"etatCheckValue\");\r\n        const archivedRule = this.ruleExtractor(\"archivedCheckValue\");\r\n        const etatDataAtCell = this.hot.getDataAtRowProp(r, \"etat\");\r\n        const archivedDataAtCell = this.hot.getDataAtRowProp(r, \"archived\");\r\n\r\n        const checkEtatValue = etatRule.isValue.includes(etatDataAtCell)\r\n        const checkArchivedValue = archivedRule.isValue.includes(archivedDataAtCell)\r\n\r\n        const response = (checkEtatValue && checkArchivedValue);\r\n\r\n        if (!response) {\r\n            const {language} = this.props;\r\n            let message, title = \"\";\r\n\r\n            switch (restriction) {\r\n                case 'Lock' : title = language.lockModeRestrictionTitle; message = language.lockModeRestriction; break;\r\n                case 'Edit' :\r\n                default : title = language.editModeRestrictionTitle; message = language.editModeRestriction; break;\r\n            }\r\n            this.alert.showMessage(\"warning\", title, message, false);\r\n        }\r\n\r\n        return response;\r\n    }\r\n\r\n    // click event handle for edit button\r\n    handleEditClick() {\r\n\r\n        const {r, c} = this.selectedRowCoords;\r\n        if (r === null && c === null) return;\r\n\r\n        if (this.isRowCanBeEditable(r)) {\r\n\r\n            // Lock mechanism controls\r\n            const dto = this.prepareDTOforLockMechanism(r, false);\r\n\r\n            this.restApi.callApi('lock', dto).then(response => {\r\n                const json = response.resultLock;\r\n                const {user} = this.props;\r\n\r\n                // can I continue to edit ?\r\n                const continueToEdit = json.islock && json.uname === user.name;\r\n\r\n                if (continueToEdit) {\r\n\r\n                    // create backup data before editing;\r\n                    this.handsontableDataBackup = JSON.parse(JSON.stringify(this.handsontableData));\r\n\r\n                    // Change edit mode on redux\r\n                    this.props.setEdit();\r\n\r\n                    this.setCellProperties(r, c);\r\n                    this.editedRowCoords.r = r;\r\n                    this.editedRowCoords.c = c;\r\n\r\n                } else {\r\n                    this.showMessageForLockMechanism(true, json)\r\n                }\r\n            })\r\n\r\n        }\r\n    }\r\n\r\n    // click handle for add new row\r\n    async handleNewRowClick() {\r\n\r\n        await this.setStateAsync({newRowAdded : true});\r\n        this.editedRowCoords.r = 0;\r\n        this.editedRowCoords.c = 0;\r\n        this.isDuplicate = false;\r\n\r\n        // create backup data before editing;\r\n        this.handsontableDataBackup = JSON.parse(JSON.stringify(this.handsontableData));\r\n\r\n        this.props.setEdit();\r\n        this.hot.alter('insert_row', 0, 1);\r\n        this.setCellProperties(0, null);\r\n\r\n        // set initial value for newly adding rows\r\n        if (this.state.newRowAdded && !this.isDuplicate) {\r\n            this.setInitialValueOfColumn();\r\n        }\r\n    }\r\n\r\n    async handleDuplicateRowClick() {\r\n\r\n        const {r, c} = this.selectedRowCoords;\r\n        if (r === null && c === null) return;\r\n\r\n        // get existing data at row\r\n        const data = this.hot.getDataAtRow(r);\r\n\r\n        this.isDuplicate = true;\r\n        await this.handleNewRowClick();\r\n\r\n        // find radio Site column for special case. we need empty radio site for duplicated row\r\n        const radioSiteColumnIndex = this.findIndexOfColumn(0,'radioSite');\r\n        const lockStatusColumnIndex = this.findIndexOfColumn(0,'LOCK_STATUS');\r\n        const lockUserColumnIndex = this.findIndexOfColumn(0,'USER_NAME');\r\n        const lockTimeColumnIndex = this.findIndexOfColumn(0,'LOCK_TIME');\r\n\r\n        const passThisColumns = [\r\n            radioSiteColumnIndex,\r\n            lockStatusColumnIndex,\r\n            lockUserColumnIndex,\r\n            lockTimeColumnIndex]\r\n\r\n        // get column count for iteration\r\n        const colCount = this.hot.countCols();\r\n\r\n        // iterate the columns\r\n        for (let x = 0; x <= colCount; x++) {\r\n\r\n            // if column is this list, pass it, data will not copy from exist row\r\n            if (x in passThisColumns) continue;\r\n\r\n            // set data\r\n            this.hot.setDataAtCell(0, x, data[x])\r\n        }\r\n    }\r\n\r\n    handleCancelClick() {\r\n\r\n        if (!this.state.newRowAdded) {\r\n\r\n            const {r, c} = this.editedRowCoords;\r\n            if (r === null && c === null) return;\r\n\r\n            // Lock mechanism controls\r\n            const dto = this.prepareDTOforLockMechanism(r, false);\r\n\r\n            // In all circumstances call implicit unlock\r\n            this.restApi.callApi('unlock', dto);\r\n        }\r\n        this.setStateAsync({newRowAdded : false}).then(() => {\r\n            this.cancelEdit();\r\n        });\r\n    }\r\n\r\n    handleSaveClick() {\r\n        this.saveAction();\r\n    }\r\n\r\n    handleSaveHistoryClick() {\r\n        this.saveAction(true)\r\n    }\r\n\r\n    checkIsRadioSiteExists(token, radioSite) {\r\n\r\n        return new Promise((res, rej) => {\r\n\r\n            const {language} = this.props;\r\n\r\n            // if the save action doing on new row add we should check if radio site is exists\r\n            // then we need to show message to the user to continue or not.\r\n            this.restApi.callApi('isRadioSiteExists', {\r\n                token,\r\n                radioSite\r\n            }).then(radioResponse => {\r\n\r\n                if (radioResponse.isExist === true) {\r\n\r\n                    // get confirmation from user to continue\r\n                    this.alert.getConfirmation(\r\n                        \"warning\",\r\n                        language.radioSiteExistsWithSameNameTitle,\r\n                        language.radioSiteExistsWithSameNameText\r\n                    ).then(confirmation => {\r\n                        res({\r\n                            confirmation,\r\n                            isExists: radioResponse.isExist\r\n                        })\r\n                    })\r\n                } else {\r\n                    // if radio site not exist we should return false\r\n                    res({\r\n                        confirmation: null,\r\n                        isExists: radioResponse.isExist\r\n                    })\r\n                }\r\n            }).catch(err => {\r\n                rej(err)\r\n            })\r\n\r\n        })\r\n    }\r\n\r\n    // save action for row edited or new\r\n    saveAction(revision) {\r\n\r\n        const {language, token} = this.props;\r\n        const isRevision = revision ? revision : false;\r\n\r\n        this.restApi.callApi('getImportStatus', {\r\n            token\r\n        }).then(importStatusResponse => {\r\n\r\n            const {isImportOngoing} = importStatusResponse;\r\n            const {r, c} = this.editedRowCoords;\r\n\r\n\r\n            if (!isImportOngoing.isLock) {\r\n                // there isn't an import action ongoing\r\n\r\n                if (this.rowValidation) {\r\n\r\n                    if (r !== null || r !== undefined) {\r\n                        // data would send to API\r\n                        let data = this.hot.getDataAtRow(r);\r\n\r\n                        data = this.columns.reduce((newRowData, item, index) => {\r\n\r\n                            Object.assign(newRowData,\r\n                                (data[index] !== null)\r\n                                    ? {[item.data]: data[index]}\r\n                                    : {[item.data]: \"\"}\r\n                            );\r\n                            return newRowData;\r\n                        }, {});\r\n\r\n                        const mandatoryColumnsFilled = this.checkMandatoryColumnsFilled(data);\r\n\r\n                        if (mandatoryColumnsFilled) {\r\n\r\n                            const { newRowAdded: isNewRow} = this.state;\r\n\r\n                            // radio Site exists check\r\n                            if (isNewRow) {\r\n\r\n                                this.checkIsRadioSiteExists(token, data['radioSite'])\r\n                                    .then(isExistsResponse => {\r\n\r\n                                        const confirm = isExistsResponse.confirmation;\r\n                                        if (confirm || confirm === null){\r\n                                            // it means, user didn't click cancel on messagebox.\r\n                                            // confirm = null means there isnt exist radio site in db\r\n                                            this.saveIt(token, data, isNewRow, isExistsResponse.isExists, r, c)\r\n                                        }\r\n                                });\r\n\r\n                            } else {\r\n\r\n                                this.saveIt(token, data, isNewRow, isRevision, r, c)\r\n                            }\r\n\r\n                        } else {\r\n\r\n                            const title = language.mandatoryDataTitle;\r\n                            let text = language.mandatoryDataText;\r\n\r\n                            text = text.replace(\"{columns}\", this.mandatoryColumns.join(',<br>'));\r\n\r\n                            this.alert.showMessage(\"error\", title, text, false);\r\n                        }\r\n                    }\r\n\r\n                } else {\r\n\r\n                    const {language} = this.props;\r\n                    this.alert.showMessage(\"error\",\r\n                        language.validationMessageBoxTitle,\r\n                        language.validationErrorGeneralMessage,\r\n                        false)\r\n                }\r\n\r\n            } else {\r\n                const message = language.importSection.ongoingImportText.replace('{username}', isImportOngoing.uname);\r\n\r\n                this.alert.showMessage(\r\n                    'warning',\r\n                    language.importSection.ongoingImportTitle,\r\n                    message,\r\n                    false)\r\n\r\n                // import is ongoing we need to reload the data\r\n                this.resetRow(r);\r\n                this.props.setEdit();\r\n                this.dataLoad();\r\n            }\r\n        })\r\n    }\r\n\r\n    saveIt(token, row, isNewRow, isRevision, r, c) {\r\n\r\n        const {setSpinner, setEdit} = this.props;\r\n\r\n        setSpinner();\r\n\r\n        // Call backend to save row\r\n        this.restApi.callApi(\"saveRow\", {\r\n            token,\r\n            row,\r\n            isNewRow,\r\n            isRevision\r\n        }).\r\n        then(response => {\r\n\r\n            const {language} = this.props;\r\n\r\n            const {processed, log} = response.result;\r\n\r\n            const message = log.split('\\n').join('<br>');\r\n\r\n            setSpinner();\r\n\r\n            if (processed) {\r\n                this.alert.showMessage(\"success\",\r\n                    language.saveActionSuccessTitle,\r\n                    message,\r\n                    false\r\n                )\r\n\r\n                this.selectedRowCoords.c = c;\r\n                this.selectedRowCoords.r = r;\r\n                this.editedRowCoords.r = null;\r\n                this.editedRowCoords.c = null;\r\n\r\n                // Reset new row state if its true\r\n                if (this.state.newRowAdded)\r\n                    this.setState({ newRowAdded : false});\r\n\r\n                setEdit(); // set it's not edit mode anymore\r\n                this.resetRow(r); // this method will return the edit view to normal\r\n                this.dataLoad(); // load the data again from db.\r\n\r\n            } else {\r\n                // something not suitable for BE,\r\n                // FE just showing a message to user.\r\n                this.alert.showMessage(\"error\",\r\n                    language.saveActionFailTitle,\r\n                    message,\r\n                    false\r\n                )\r\n\r\n                // this will make the row re-editable if get error from backend\r\n                this.setCellProperties(r, c);\r\n\r\n            }\r\n        }).catch(() => {\r\n            // we have unexpected error from BE\r\n            // Stopping edit mode, stop everything, back to one step previous\r\n            setSpinner();\r\n            //this.cancelEdit();\r\n            //this.resetRow(r);\r\n        })\r\n    }\r\n\r\n    async revisionRowFilter() {\r\n        if (this._isMounted) {\r\n            const colIndex = this.findIndexOfColumn(0,'archived');\r\n            const {showRevision} = this.props;\r\n\r\n            const arg = showRevision ? '' : 'NO'; // this param is for filtering on handsontable\r\n\r\n            if (showRevision) {\r\n                this.filter.removeConditions(colIndex);\r\n            } else {\r\n                this.filter.addCondition(colIndex, 'contains', arg);\r\n            }\r\n            await this.filter.filter();\r\n        }\r\n    }\r\n\r\n    setCellProperties(r, c) {\r\n\r\n        const colCount = this.hot.countCols();\r\n        let col = c !== null ? c : 0;\r\n\r\n        for (let x = 0; x <= colCount; x++) {\r\n            const {prop, readOnly, readOnlyInEditMode} = this.hot.getCellMeta(r,x);\r\n\r\n            if (typeof prop !== \"string\") continue\r\n\r\n            // if prop has got readyOnly attribute with value \"true\", write permission will restricted\r\n            // if prop hasn't got readOnly attribute it would be false by default. So we need to check if\r\n            // this action is adding new row or editing existing row.\r\n            // if action is editing a row then we should check readOnlyInEditMode attribute of prop.\r\n            // if it's exist we should get opposite value because if we add this attribute to prop it value should be \"true\"\r\n            // it means this property can not be writable in edit mode\r\n            // if readOnlyInEditMode attribute is not exist in prop there isn't extra attribute checking for this cell\r\n            // can be writable or not. So we can put \"true\" value to associated variable.\r\n            const writable = readOnly ? !readOnly : !this.state.newRowAdded ? !readOnlyInEditMode : !readOnly;\r\n\r\n            if (writable) {\r\n                if (this.state.permittedColumns.indexOf(prop) >= 0) {\r\n\r\n                    const type = this.hot.getDataType(r, x); // get cell type from loaded map\r\n\r\n                    // this 2 row for initiate the rules on editing row.\r\n                    //const value = this.hot.getDataAtCell(r, x);\r\n                    //this.columnEvents(r, prop, value);\r\n\r\n                    col = col === 0 ? x : col; // when add new row find first editable col.\r\n\r\n                    this.hot.setCellMeta(r, x, \"editor\", type);\r\n                    this.hot.setCellMeta(r, x, \"className\", 'bg-warning text-dark');\r\n                }\r\n            }\r\n        }\r\n        this.hot.render();\r\n        this.hot.selectCell(r, col);\r\n    }\r\n\r\n    findIndexOfColumn(r, propName) {\r\n        const colCount = this.hot.countCols();\r\n        for (let c = 0; c <= colCount; c++) {\r\n            const {prop} = this.hot.getCellMeta(r,c);\r\n            if (prop === propName) {\r\n                return c;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Before save action mandatory columns are must be filled\r\n    checkMandatoryColumnsFilled(rowData) {\r\n\r\n        const checkData = this.mandatoryColumns.reduce((data, columnId) => {\r\n            data.push(rowData[columnId]);\r\n            return data;\r\n        }, []);\r\n\r\n        return checkData.every(data => {\r\n            return data !== undefined && data !== \"\" && data !== null\r\n        })\r\n    }\r\n\r\n    // Finished initial value setter\r\n    setInitialValueOfColumn() {\r\n        this.columns.map((item) => {\r\n            if (item.hasOwnProperty('initialValue')) {\r\n                this.hot.setDataAtRowProp(0, item.data, item.initialValue)\r\n            }\r\n            return true;\r\n        })\r\n    }\r\n\r\n    // Finished, cancel edit return back to last backup data\r\n    cancelEdit() {\r\n        this.handsontableData = JSON.parse(JSON.stringify(this.handsontableDataBackup));\r\n        this.hot.loadData(this.handsontableData);\r\n        this.hot.render();\r\n\r\n        // Change edit mode on redux\r\n        this.props.setEdit();\r\n    }\r\n\r\n    // reset row finished\r\n    resetRow(r) {\r\n        const colCount = this.hot.countCols();\r\n        for (let x = 0; x <= colCount; x++) {\r\n\r\n            this.hot.setCellMeta(r, x, \"editor\", false);\r\n            this.hot.setCellMeta(r, x, \"className\", 'bg-primary text-white');\r\n        }\r\n        this.hot.render();\r\n        this.setState({ newRowAdded : false});\r\n    }\r\n\r\n    // reset seleted rows for some reason such as change region, change active page\r\n    resetSelectedRow() {\r\n\r\n        this.selectedRowCoords.r = null\r\n        this.selectedRowCoords.c = null\r\n        this.editedRowCoords.r = null\r\n        this.editedRowCoords.c = null\r\n        this.validatedCell.r = null\r\n        this.validatedCell.c = null\r\n\r\n        this.hot.deselectCell();\r\n    }\r\n\r\n    // disable moves finished\r\n    disableMoves() {\r\n        return false;\r\n    }\r\n\r\n    // Finished ip validation rule\r\n    ipValidate(value, callback) {\r\n\r\n        const pat = /^(?:\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b|null)$/;\r\n\r\n        this.rowValidation = pat.test(value);\r\n        callback(this.rowValidation);\r\n        if (!this.rowValidation)\r\n            this.showMessage(this.errorBoxTitle, this.errorMessages.invalidIP, true, true);\r\n    }\r\n\r\n    // Finished numeric value validation\r\n    numericValidate(value, callback) {\r\n\r\n        const pat = /^\\d+$/;\r\n\r\n        this.rowValidation = pat.test(value);\r\n        callback(this.rowValidation);\r\n        if (!this.rowValidation)\r\n            this.showMessage(this.errorBoxTitle, this.errorMessages.invalidNumber, true, true);\r\n    }\r\n\r\n    // Finished validation message box\r\n    showMessage(title, message, validatorClose, isMandatoryColumn) {\r\n        confirmAlert({\r\n            title: 'Validation Warning',\r\n            message: message,\r\n            closeOnEscape: false,\r\n            closeOnClickOutside: false,\r\n            customUI: ({ onClose }) => {\r\n\r\n                const closeAction = () => {\r\n                    if (validatorClose) {\r\n                        if (isMandatoryColumn) {\r\n                            const {r, c} = this.validatedCell;\r\n                            this.hot.selectCell(r, c);\r\n\r\n                            if (this.hot.getActiveEditor() !== undefined) {\r\n\r\n                                const existingValueInCell = this.hot.getDataAtCell(r, c);\r\n\r\n                                this.hot.getActiveEditor().beginEditing();\r\n                                this.hot.getActiveEditor().setValue(existingValueInCell);\r\n                            }\r\n                        }\r\n                        onClose();\r\n\r\n                    } else {\r\n                        this.cancelEdit();\r\n                        onClose();\r\n                    }\r\n                }\r\n                return (\r\n                    <div className=\"card\">\r\n                        <div className=\"card-header\">\r\n                            {title}\r\n\r\n                            <button type=\"button\" className=\"close\"\r\n                                    onClick={closeAction}\r\n                                    aria-label=\"Close\">\r\n                                <span aria-hidden=\"true\">&times;</span>\r\n                            </button>\r\n\r\n                        </div>\r\n                        <div className=\"card-body\">\r\n                            <div className={'card-text text-danger'}>{message}</div>\r\n                        </div>\r\n                        <div className=\"card-footer\">\r\n                            <button className={'btn btn-warning'} onClick={closeAction}>\r\n                                Ok\r\n                            </button>\r\n                        </div>\r\n                    </div>\r\n                );\r\n            }\r\n        });\r\n    }\r\n\r\n    // Finished column header groups\r\n    handleColumnHeaders() {\r\n\r\n        // Create a copy of map file\r\n        const headerMap = JSON.parse(JSON.stringify(groupingMap));\r\n\r\n        // Set the header groups for table\r\n        const headerGrouping = headerMap.filter((item) => {\r\n            item.colspan = item.columns.length;\r\n            return typeof item.columns === \"object\"\r\n        })\r\n\r\n        // set each and every column defaults\r\n        const cols = headerMap.map((item) => {\r\n\r\n            return item.columns.map(c => {\r\n\r\n                this.titles.push(c.label);\r\n\r\n                c.color = item.color;\r\n\r\n                c.editor = false; // default readonly\r\n\r\n                if (typeof c.validator !== \"undefined\") {\r\n\r\n                    if (c.validator === 'ipValidator') {\r\n                        c.validator = (value, callback) => {\r\n                            this.ipValidate(value, callback)\r\n                        }\r\n                    }\r\n\r\n                    if (c.validator === 'isNumeric') {\r\n                        c.validator = (value, callback) => {\r\n                            this.numericValidate(value, callback)\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (typeof c.type !== \"undefined\") {\r\n                    if (c.type === 'dropdown') {\r\n                        this.setPickList(c.data).then((list) => {\r\n                            c.source = list;\r\n                        });\r\n                    }\r\n                }\r\n\r\n                if (typeof c.rerenderer !== \"undefined\") {\r\n                    c.renderer = this.iconForLockStatusInCell.bind(this);\r\n                    delete c.rerenderer;\r\n                }\r\n\r\n                return c;\r\n            });\r\n        })\r\n        console.log(this.columns);\r\n\r\n        // spread the columns into single object\r\n        cols.map((c) => {\r\n            console.log(c);\r\n            this.columns = [...this.columns, ...c];\r\n        })\r\n\r\n\r\n\r\n        // Pushing header group const to related vars\r\n        this.columnHeaders.push(headerGrouping);\r\n        this.columnHeaders.push(this.titles);\r\n\r\n        console.log(this.columnHeaders);\r\n        console.log(this.columns);\r\n    }\r\n\r\n    // Finished colouring header\r\n    headerColoring(col, TH) {\r\n\r\n        const TR = TH.parentNode;\r\n        const THEAD = TR.parentNode;\r\n\r\n        const b = THEAD.childNodes.length;\r\n        const n = Array.prototype.indexOf.call(THEAD.childNodes, TR);\r\n        const headerLevel = (-1) * b + n;\r\n\r\n        function applyClass(elem, className) {\r\n            if (!Handsontable.dom.hasClass(elem, className))\r\n                Handsontable.dom.addClass(elem, className);\r\n        }\r\n\r\n        if (headerLevel === -1 || headerLevel === -2) {\r\n\r\n            if (col in this.columns) {\r\n\r\n                const {color} = this.columns[col];\r\n                if (color) applyClass(TH, color);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Finished pick list setter function\r\n    setPickList(name) {\r\n        return new Promise ((res, rej) => {\r\n\r\n            const value = `${name}Picklist_value`;\r\n            const key = `${name}Picklist`;\r\n\r\n            this.restApi.callApi('getPickList', {\r\n                token: this.props.token,\r\n                pickListName: key\r\n\r\n            }).then((response) => {\r\n\r\n                if (response.pickList.length > 0) {\r\n                     const list = response.pickList.map((item) => {\r\n                        return item[value];\r\n                    })\r\n                    res(list)\r\n                }\r\n            }).catch((error) => {\r\n                console.log(error)\r\n            });\r\n        })\r\n    }\r\n\r\n    // Read the rule from imported rule file\r\n    mandatoryColumnExtractor() {\r\n        return groupingMap.reduce((fullArr, item) => {\r\n            const cols = item.columns.reduce((arr, col) => {\r\n                if (col.mandatory) arr.push(col.data)\r\n                return arr;\r\n            }, []);\r\n            return [...fullArr, ...cols]\r\n        }, [])\r\n    }\r\n\r\n    // Read the rule from imported rule file\r\n    ruleExtractor(columnId) {\r\n        return columnLogic.find((item) => {\r\n            return item.id === columnId;\r\n        })\r\n    }\r\n\r\n    // Generic attributes validations and rule runner\r\n    async columnEvents(r, c, newV) {\r\n\r\n        this.validatedCell.r = r;\r\n        this.validatedCell.c = c;\r\n\r\n        const properties = this.ruleExtractor(c);\r\n        if (properties) {\r\n            const {methodCaller, rules, executeRules, paramName, additionalParams, ruleChain} = properties;\r\n\r\n            if (methodCaller) {\r\n                // we understand that this logic needs to call api\r\n\r\n                // default dto\r\n                let dto = {\r\n                    token: this.props.token,\r\n                    [paramName]: this.hot.getDataAtRowProp(r, c)\r\n                };\r\n\r\n                if (typeof additionalParams !== 'undefined' &&\r\n                    typeof additionalParams === 'object') {\r\n\r\n                    // create addition parameter to bind exact one\r\n                    const additionalDTO = additionalParams.map((prop) => {\r\n                        return {[prop]: this.hot.getDataAtRowProp(r, prop)}\r\n                    });\r\n\r\n                    // dto with additional parameters\r\n                    dto = Object.assign({}, dto, ...additionalDTO);\r\n                }\r\n\r\n                // method caller and logic execution\r\n                //await this.genericCL(methodCaller, dto);\r\n                this.restApi.callApi(methodCaller, dto).then((response) => {\r\n\r\n                    if (typeof response.isExist !== 'undefined') {\r\n\r\n                        if (!response.isExist) {\r\n                            // value is not exist in DB, show message\r\n\r\n                            // add this row, if column is mandatory, user must fill this cell with correct value\r\n                            const isMandatoryColumn = this.mandatoryColumns.includes(c);\r\n                            // show message and execute logic\r\n                            this.showMessage(this.errorBoxTitle, this.errorMessages[c], true, isMandatoryColumn);\r\n\r\n                            this.rowValidation = false; // row has error\r\n                            return false;\r\n\r\n                        } else {\r\n                            // value is exist in DB, check other rules associated with that one\r\n                            if (executeRules && executeRules.length > 0) {\r\n                                executeRules.map(props => {\r\n\r\n                                    const {propId} = props;\r\n                                    const data = this.hot.getDataAtRowProp(r, propId)\r\n\r\n                                    this.columnEvents(r, propId, data)\r\n                                })\r\n                            }\r\n                            this.rowValidation = true; // row passed all validation\r\n                        }\r\n\r\n                        if (ruleChain && ruleChain.length > 0) {\r\n                            this.ruleChainHandle(ruleChain, dto, r)\r\n                        }\r\n                    } else {\r\n                        rules[0].changedValue = response.List.map(i => {return i.value})\r\n                        this.staticRules(r, null, rules);\r\n                    }\r\n                })\r\n\r\n            } else {\r\n                this.staticRules(r, newV, rules)\r\n            }\r\n        }\r\n    }\r\n\r\n    ruleChainHandle(ruleChain, dto, r) {\r\n\r\n        ruleChain.map(item => {\r\n            if (item.parentResponse) {\r\n                this.restApi.callApi(item.methodCaller, dto).then(response => {\r\n                    const { exec_status } = response;\r\n\r\n                    if (item.responseType === \"string\") {\r\n                        const value = response[item.parsingKey]\r\n                        if (exec_status === \"success\") {\r\n                            this.staticRules(r, value, item.rules)\r\n                        }\r\n                    }\r\n\r\n                    if (item.responseType === \"object\") {\r\n                        const obj = response[item.parsingKey]\r\n\r\n                        const list = obj.reduce((arr, i) => {\r\n                            return [...arr, i[item.parsingKey]]\r\n                        }, [])\r\n\r\n                        this.hot.setCellMeta(r, this.hot.propToCol(item.parsingKey), 'source', list);\r\n                        this.hot.setDataAtRowProp(r, item.parsingKey, list[0]);\r\n                    }\r\n                })\r\n            }\r\n        })\r\n    }\r\n\r\n    staticRules(r, value, rules) {\r\n        if (rules) {\r\n            rules.map((item) => {\r\n                if (item.columnValue && value) {\r\n                    if (item.columnValue === value) {\r\n                        // status changes\r\n                        this.hot.setDataAtRowProp(r, item.changedId, item.changedValue);\r\n                    }\r\n                } else if (!item.columnValue && value) {\r\n\r\n                    this.hot.setDataAtRowProp(r, item.changedId, value);\r\n\r\n                } else {\r\n                    this.hot.setCellMeta(r, this.hot.propToCol(item.changedId), 'source', item.changedValue);\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    handleExport() {\r\n        const {token, region, radioSite} = this.props;\r\n        this.props.setSpinner();\r\n\r\n        this.restApi.callApi('exportData', {\r\n            region,\r\n            token,\r\n            radioSite\r\n        }).then(response => {\r\n            const today = new Date();\r\n            //const todayDate =  '_' + today.getDate() +  (today.toLocaleString('default', { month: 'long' })) + today.getFullYear();\r\n\r\n            const todayDate = '_' + today.getFullYear() + '-' + (today.getMonth()+1) + '-' + today.getDate() + 'T' + today.getHours() + '.' + today.getMinutes()\r\n\r\n            const ws = XLSX.utils.json_to_sheet(response.ExportedExcelAsJSON);\r\n            const wb = { Sheets: { 'data': ws }, SheetNames: ['data'] };\r\n            const excelBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });\r\n            const data = new Blob([excelBuffer], {type: 'xlsx'});\r\n\r\n           // saveAs(data, `DataMatrix${todayDate}.xlsx`);\r\n            saveAs(data, `Exported_RANConn${todayDate}.xlsx`);\r\n            this.props.setSpinner();\r\n\r\n        }).catch((error) => {\r\n            console.log(error)\r\n            this.props.setSpinner();\r\n\r\n        });\r\n    }\r\n\r\n    handleLockClick() {\r\n\r\n        const {r} = this.selectedRowCoords;\r\n        if (r === null) return;\r\n\r\n        if (this.isRowCanBeEditable(r, 'Lock')) {\r\n            const dto = this.prepareDTOforLockMechanism(r, true);\r\n\r\n            this.restApi.callApi('lock', dto).then(response => {\r\n                this.showMessageForLockMechanism(true, response.resultLock);\r\n                this.dataLoad();\r\n            })\r\n        }\r\n    }\r\n\r\n    handleUnlockClick() {\r\n        const {r} = this.selectedRowCoords;\r\n        if (r === null) return;\r\n\r\n        if (this.isRowCanBeEditable(r, 'Lock')) {\r\n            const dto = this.prepareDTOforLockMechanism(r, true);\r\n\r\n            this.restApi.callApi('unlock', dto).then(response => {\r\n                this.showMessageForLockMechanism(false, response.resultUnlock);\r\n                this.dataLoad();\r\n            })\r\n        }\r\n    }\r\n\r\n    prepareDTOforLockMechanism(r, isExplicit) {\r\n        const {token} = this.props;\r\n\r\n        // get existing data at row\r\n        const data = this.hot.getDataAtRow(r);\r\n        const radioSiteColumnIndex = this.findIndexOfColumn(0,'radioSite');\r\n        const revisionNumberColumnIndex = this.findIndexOfColumn(0,'revisionNumber');\r\n\r\n        const radioSite = data[radioSiteColumnIndex].toString();\r\n        const revisionNumber = data[revisionNumberColumnIndex].toString();\r\n\r\n        return {\r\n            token,\r\n            radioSite,\r\n            revisionNumber,\r\n            isExplicit\r\n        }\r\n    }\r\n\r\n    showMessageForLockMechanism(messageForLock, result) {\r\n\r\n        const {lockMechanism, unlockMechanism} = this.props.language;\r\n\r\n        const title = messageForLock ? lockMechanism.title : unlockMechanism.title;\r\n        let message = messageForLock ? lockMechanism[result.code.toString()] : unlockMechanism[result.code.toString()]\r\n\r\n        message = message\r\n            ? message.replace(\"{uname}\", result.uname).replace(\"{time}\", new Date(result.time).toLocaleString())\r\n            : \"Undefined\";\r\n\r\n        this.alert.showMessage('info', title, message, false);\r\n    }\r\n\r\n    iconForLockStatusInCell(instance, td, row, col, prop, value) {\r\n\r\n        const {language} = this.props;\r\n\r\n        switch (value) {\r\n            case \"Locked_Current_User\" : {\r\n                const message = language.lockStatusMessages.Locked_Current_User;\r\n                td.innerHTML = '<strong class=\"icon icon-lock-locked text-danger\" title=\"'+message+'\" />';\r\n            } break;\r\n\r\n            case \"Locked_Other_User\" : {\r\n                const message = language.lockStatusMessages.Locked_Other_User;\r\n                td.innerHTML = '<strong class=\"text-danger\" title=\"'+message+'\">' +\r\n                    '<i class=\"icon icon-lock-locked\"></i>' +\r\n                    '<i class=\"icon icon-avatar\"></i>' +\r\n                    '</strong>';\r\n            } break;\r\n\r\n            default: {\r\n                const message = language.lockStatusMessages.Not_Locked;\r\n                td.innerHTML = '<strong class=\"icon icon-lock-unlocked\" title=\"'+message+'\" />';\r\n            } break;\r\n\r\n        }\r\n        td.classList.add(\"text-center\")\r\n        return td;\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps, nextState, nextContext) {\r\n        return nextState.isDataExistsInDB !== this.state.isDataExistsInDB ||\r\n            nextState.activePage !== this.state.activePage ||\r\n            nextState.totalCountOfData !== this.state.totalCountOfData ||\r\n            nextState.newRowAdded !== this.state.newRowAdded ||\r\n            nextState.maximize !== this.props.maximize\r\n    }\r\n\r\n    render() {\r\n        const {maximize, language, contentCSS, showRevision} = this.props;\r\n\r\n        if (language) {\r\n            this.errorBoxTitle = language.validationMessageBoxTitle;\r\n            this.errorMessages = language.validationErrorMessages;\r\n        }\r\n\r\n        return (\r\n            <>\r\n                <Header/>\r\n                <Row className=\"h-100\">\r\n                    <Sidebar maximize={maximize}/>\r\n                    <Col className={contentCSS}>\r\n                        <Toolbar\r\n                            wrapper={'toolbar mt-2'}\r\n                            isDataExist={this.state.isDataExistsInDB}\r\n                            newRowAdded={this.state.newRowAdded}\r\n                            export={this.handleExport.bind(this)}\r\n                            lock={this.handleLockClick.bind(this)}\r\n                            unlock={this.handleUnlockClick.bind(this)}\r\n                            new={this.handleNewRowClick.bind(this)}\r\n                            duplicate={this.handleDuplicateRowClick.bind(this)}\r\n                            edit={this.handleEditClick.bind(this)}\r\n                            cancel={this.handleCancelClick.bind(this)}\r\n                            save={this.handleSaveClick.bind(this)}\r\n                            save-history={this.handleSaveHistoryClick.bind(this)}\r\n                            revision={this.revisionRowFilter.bind(this)}\r\n                            handleRegionChange={this.dataLoad.bind(this)}\r\n                            handleRadioSiteChange={this.dataLoad.bind(this)}\r\n                        />\r\n\r\n                        <Card className={'mt-1 fixedCard'}>\r\n                            <CardBody>\r\n                                <HotTable ref={this.hotTableComponent} id={'hot'}\r\n                                  licenseKey={'non-commercial-and-evaluation'}\r\n                                  nestedHeaders={this.columnHeaders}\r\n                                  columns={this.columns}\r\n                                  stretchH={'all'}\r\n                                  dropdownMenu={true}\r\n                                  filters={true}\r\n                                  manualColumnResize={true}\r\n                                  width={'100%'}\r\n                                  height={'100%'}\r\n                                  fixedColumnsLeft={0}\r\n                                  columnSorting={true}\r\n                                  currentRowClassName={['bg-primary', 'text-white']}\r\n                                  enterBeginsEditing={false}\r\n                                  outsideClickDeselects={false}\r\n                                  enterMoves={this.disableMoves()}\r\n                                  fillHandle={this.disableMoves()}\r\n                                  afterSelectionEnd={(r, c) => {\r\n                                      this.selectedRowCoords.r = r;\r\n                                      this.selectedRowCoords.c = c;\r\n                                  }}\r\n                                  afterValidate={(isValid, value, row, prop) => {\r\n                                      // this is check dropdown values are proper or not.\r\n                                      this.validatedCell.r = row;\r\n                                      this.validatedCell.c = prop;\r\n                                  }}\r\n                                  afterGetColHeader={(col, TH) => {\r\n                                      this.headerColoring(col, TH)\r\n                                  }}\r\n                                  afterCreateRow={(index, amount, source) => {\r\n                                      //console.log(index, amount, source)\r\n                                  }}\r\n                                  afterRenderer={(td, r) => {\r\n                                      if (showRevision) {\r\n                                          const v = this.hot.getDataAtRowProp(r, 'archived');\r\n                                          if (['YES', 'Yes', 'yes'].includes(v)) {\r\n                                              td.classList.add('revision-row')\r\n                                          }\r\n                                      }\r\n                                  }}\r\n                                  afterChange={(changes) => {\r\n                                      // TODO: check esc button when its clicked\r\n                                      if (changes) {\r\n                                          const [r, c, oldV, newV] = changes[0];\r\n                                          // check cell value if it's different previous one and\r\n                                          // if row still has error -> we need that because\r\n                                          // if user doesnt change value at second time, validation rule not execute.\r\n                                          if (oldV !== newV || !this.rowValidation)\r\n                                            this.columnEvents(r, c, newV);\r\n                                      }\r\n                                  }}\r\n                                />\r\n\r\n                                {!this.state.isDataExistsInDB &&\r\n                                    <EmptyDataset page={'matrix'}/>\r\n                                }\r\n                            </CardBody>\r\n\r\n                            {/*<CardFooter className={'text-center'}>\r\n                                <PaginationMatrix\r\n                                    activePage={this.state.activePage}\r\n                                    itemPerPage={this.state.itemPerPage}\r\n                                    totalCountOfData={this.state.totalCountOfData}\r\n                                    handlePageChange={this.handlePageChange.bind(this)}\r\n                                />\r\n                            </CardFooter>*/}\r\n                        </Card>\r\n                    </Col>\r\n                </Row>\r\n\r\n                <ModalImport loadAfterImport={this.dataLoad.bind(this)}/>\r\n                <Spinner/>\r\n            </>\r\n        )\r\n    }\r\n}\r\n\r\nfunction mapStateToProps(state) {\r\n    return {\r\n        token: state.token,\r\n        user: state.user,\r\n        language: state.language,\r\n        maximize: state.maximize,\r\n        contentCSS: state.contentCSS,\r\n        region: state.region,\r\n        radioSite: state.radioSite,\r\n        spinnerToggle: state.spinnerToggle,\r\n        showRevision: state.showRevision\r\n    }\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch) {\r\n    return {\r\n        setEdit: () => dispatch(editOnToggle()),\r\n        setSpinner: () => dispatch(spinnerToggle()),\r\n    }\r\n\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Matrix);"]},"metadata":{},"sourceType":"module"}